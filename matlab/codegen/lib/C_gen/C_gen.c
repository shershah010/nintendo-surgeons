/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * C_gen.c
 *
 * Code generation for function 'C_gen'
 *
 */

/* Include files */
#include <math.h>
#include "rt_nonfinite.h"
#include "C_gen.h"
#include "G_gen.h"
#include "M_gen.h"
#include "u_model.h"
#include "C_gen_emxutil.h"
#include "power.h"
#include "sin.h"
#include "cos.h"
#include "rdivide_helper.h"

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double y;
  double d0;
  double d1;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d0 = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d0 == 1.0) {
        y = 1.0;
      } else if (d0 > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

void C_gen(const emxArray_real_T *q, const emxArray_real_T *dq, emxArray_real_T *
           C)
{
  emxArray_real_T *t5;
  int k;
  int nx;
  emxArray_real_T *t6;
  emxArray_real_T *t9;
  emxArray_real_T *t8;
  emxArray_real_T *t13;
  emxArray_real_T *t10;
  emxArray_real_T *t15;
  emxArray_real_T *t17;
  emxArray_real_T *r0;
  emxInit_real_T(&t5, 2);

  /* C_GEN */
  /*     C = C_GEN(Q,DQ) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     09-Dec-2019 15:26:08 */
  k = t5->size[0] * t5->size[1];
  t5->size[0] = 1;
  t5->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t5, k);
  nx = q->size[0] * q->size[1];
  for (k = 0; k < nx; k++) {
    t5->data[k] = q->data[k] + 0.0001;
  }

  emxInit_real_T(&t6, 2);
  k = t6->size[0] * t6->size[1];
  t6->size[0] = 1;
  t6->size[1] = t5->size[1];
  emxEnsureCapacity_real_T(t6, k);
  nx = t5->size[0] * t5->size[1];
  for (k = 0; k < nx; k++) {
    t6->data[k] = t5->data[k];
  }

  b_cos(t6);
  b_sin(t5);
  k = C->size[0] * C->size[1];
  C->size[0] = 1;
  C->size[1] = q->size[1];
  emxEnsureCapacity_real_T(C, k);
  nx = q->size[0] * q->size[1];
  for (k = 0; k < nx; k++) {
    C->data[k] = q->data[k] / 2.0 + 5.0E-5;
  }

  emxInit_real_T(&t9, 2);
  k = t9->size[0] * t9->size[1];
  t9->size[0] = 1;
  t9->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t9, k);
  nx = q->size[0] * q->size[1];
  for (k = 0; k < nx; k++) {
    t9->data[k] = q->data[k] * 10000.0 + 1.0;
  }

  emxInit_real_T(&t8, 2);
  emxInit_real_T(&t13, 2);
  rdivide_helper(t9, t8);
  k = t13->size[0] * t13->size[1];
  t13->size[0] = 1;
  t13->size[1] = C->size[1];
  emxEnsureCapacity_real_T(t13, k);
  nx = C->size[0] * C->size[1];
  for (k = 0; k < nx; k++) {
    t13->data[k] = C->data[k];
  }

  emxInit_real_T(&t10, 2);
  b_cos(t13);
  b_sin(C);
  power(t8, t9);
  k = t10->size[0] * t10->size[1];
  t10->size[0] = 1;
  t10->size[1] = t8->size[1];
  emxEnsureCapacity_real_T(t10, k);
  nx = t8->size[1];
  for (k = 0; k < nx; k++) {
    t10->data[k] = rt_powd_snf(t8->data[k], 3.0);
  }

  emxInit_real_T(&t15, 2);
  k = t15->size[0] * t15->size[1];
  t15->size[0] = 1;
  t15->size[1] = t6->size[1];
  emxEnsureCapacity_real_T(t15, k);
  nx = t6->size[0] * t6->size[1];
  for (k = 0; k < nx; k++) {
    t15->data[k] = t6->data[k] / 2.0 - 0.5;
  }

  emxInit_real_T(&t17, 2);
  k = t17->size[0] * t17->size[1];
  t17->size[0] = 1;
  t17->size[1] = t5->size[1];
  emxEnsureCapacity_real_T(t17, k);
  nx = t5->size[0] * t5->size[1];
  for (k = 0; k < nx; k++) {
    t17->data[k] = t5->data[k] * t8->data[k] * 420.0;
  }

  k = t6->size[0] * t6->size[1];
  nx = t8->size[0] * t8->size[1];
  t8->size[0] = 1;
  t8->size[1] = t6->size[1];
  emxEnsureCapacity_real_T(t8, nx);
  nx = k - 1;
  for (k = 0; k <= nx; k++) {
    t8->data[k] = -(t6->data[k] * t8->data[k] * 420.0);
  }

  emxInit_real_T(&r0, 2);
  k = r0->size[0] * r0->size[1];
  r0->size[0] = 1;
  r0->size[1] = t5->size[1];
  emxEnsureCapacity_real_T(r0, k);
  nx = t5->size[0] * t5->size[1];
  for (k = 0; k < nx; k++) {
    r0->data[k] = t5->data[k] * t9->data[k];
  }

  k = dq->size[0] * dq->size[1];
  nx = C->size[0] * C->size[1];
  C->size[0] = 1;
  C->size[1] = dq->size[1];
  emxEnsureCapacity_real_T(C, nx);
  nx = k - 1;
  for (k = 0; k <= nx; k++) {
    C->data[k] = dq->data[k] * (((C->data[k] * 0.021 + t8->data[k]) + r0->data[k]
      * 4.2E+6) * (((t13->data[k] * 0.0105 + t17->data[k]) + t6->data[k] *
                    t9->data[k] * 8.4E+6) - t5->data[k] * t10->data[k] * 8.4E+10)
      * 0.035 - ((t13->data[k] * 0.021 + t17->data[k]) + t9->data[k] * t15->
                 data[k] * 8.4E+6) * (((C->data[k] * 0.0105 + t8->data[k]) +
      r0->data[k] * 8.4E+6) + t10->data[k] * t15->data[k] * 1.68E+11) * 0.035);
  }

  emxFree_real_T(&r0);
  emxFree_real_T(&t17);
  emxFree_real_T(&t15);
  emxFree_real_T(&t10);
  emxFree_real_T(&t9);
  emxFree_real_T(&t13);
  emxFree_real_T(&t8);
  emxFree_real_T(&t6);
  emxFree_real_T(&t5);
}

/* End of code generation (C_gen.c) */
