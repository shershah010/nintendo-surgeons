/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * M_gen.c
 *
 * Code generation for function 'M_gen'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "C_gen.h"
#include "G_gen.h"
#include "M_gen.h"
#include "u_model.h"
#include "C_gen_emxutil.h"
#include "power.h"
#include "sin.h"
#include "cos.h"
#include "rdivide_helper.h"

/* Function Definitions */
void M_gen(const emxArray_real_T *q, emxArray_real_T *M)
{
  emxArray_real_T *t5;
  int i3;
  int loop_ub;
  emxArray_real_T *t6;
  emxArray_real_T *t10;
  emxArray_real_T *b_q;
  emxArray_real_T *t8;
  emxArray_real_T *t9;
  emxArray_real_T *r3;
  emxInit_real_T(&t5, 2);

  /* M_GEN */
  /*     M = M_GEN(Q) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     09-Dec-2019 15:26:07 */
  i3 = t5->size[0] * t5->size[1];
  t5->size[0] = 1;
  t5->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t5, i3);
  loop_ub = q->size[0] * q->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    t5->data[i3] = q->data[i3] + 0.0001;
  }

  emxInit_real_T(&t6, 2);
  i3 = t6->size[0] * t6->size[1];
  t6->size[0] = 1;
  t6->size[1] = t5->size[1];
  emxEnsureCapacity_real_T(t6, i3);
  loop_ub = t5->size[0] * t5->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    t6->data[i3] = t5->data[i3];
  }

  emxInit_real_T(&t10, 2);
  b_cos(t6);
  b_sin(t5);
  i3 = t10->size[0] * t10->size[1];
  t10->size[0] = 1;
  t10->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t10, i3);
  loop_ub = q->size[0] * q->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    t10->data[i3] = q->data[i3] / 2.0 + 5.0E-5;
  }

  emxInit_real_T(&b_q, 2);
  i3 = b_q->size[0] * b_q->size[1];
  b_q->size[0] = 1;
  b_q->size[1] = q->size[1];
  emxEnsureCapacity_real_T(b_q, i3);
  loop_ub = q->size[0] * q->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    b_q->data[i3] = q->data[i3] * 10000.0 + 1.0;
  }

  emxInit_real_T(&t8, 2);
  emxInit_real_T(&t9, 2);
  emxInit_real_T(&r3, 2);
  rdivide_helper(b_q, t8);
  power(t8, t9);
  i3 = r3->size[0] * r3->size[1];
  r3->size[0] = 1;
  r3->size[1] = t10->size[1];
  emxEnsureCapacity_real_T(r3, i3);
  loop_ub = t10->size[0] * t10->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    r3->data[i3] = t10->data[i3];
  }

  b_cos(r3);
  i3 = b_q->size[0] * b_q->size[1];
  b_q->size[0] = 1;
  b_q->size[1] = r3->size[1];
  emxEnsureCapacity_real_T(b_q, i3);
  loop_ub = r3->size[0] * r3->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    b_q->data[i3] = (r3->data[i3] * 0.021 + t9->data[i3] * (t6->data[i3] / 2.0 -
      0.5) * 8.4E+6) + t5->data[i3] * t8->data[i3] * 420.0;
  }

  power(b_q, M);
  b_sin(t10);
  i3 = b_q->size[0] * b_q->size[1];
  b_q->size[0] = 1;
  b_q->size[1] = t10->size[1];
  emxEnsureCapacity_real_T(b_q, i3);
  loop_ub = t10->size[0] * t10->size[1];
  for (i3 = 0; i3 < loop_ub; i3++) {
    b_q->data[i3] = (t10->data[i3] * 0.021 - t6->data[i3] * t8->data[i3] * 420.0)
      + t5->data[i3] * t9->data[i3] * 4.2E+6;
  }

  emxFree_real_T(&t9);
  emxFree_real_T(&t8);
  emxFree_real_T(&t10);
  emxFree_real_T(&t6);
  emxFree_real_T(&t5);
  power(b_q, r3);
  i3 = M->size[0] * M->size[1];
  loop_ub = M->size[0] * M->size[1];
  M->size[0] = 1;
  emxEnsureCapacity_real_T(M, loop_ub);
  loop_ub = i3 - 1;
  emxFree_real_T(&b_q);
  for (i3 = 0; i3 <= loop_ub; i3++) {
    M->data[i3] = M->data[i3] * 0.035 + r3->data[i3] * 0.035;
  }

  emxFree_real_T(&r3);
}

/* End of code generation (M_gen.c) */
