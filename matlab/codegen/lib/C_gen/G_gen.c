/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * G_gen.c
 *
 * Code generation for function 'G_gen'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "C_gen.h"
#include "G_gen.h"
#include "M_gen.h"
#include "u_model.h"
#include "C_gen_emxutil.h"
#include "sin.h"
#include "rdivide_helper.h"
#include "power.h"
#include "cos.h"

/* Function Definitions */
void G_gen(const emxArray_real_T *q, emxArray_real_T *G)
{
  emxArray_real_T *t4;
  int i1;
  int loop_ub;
  emxArray_real_T *t3;
  emxArray_real_T *r1;
  emxArray_real_T *r2;
  emxInit_real_T(&t4, 2);

  /* G_GEN */
  /*     G = G_GEN(Q) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     09-Dec-2019 15:26:08 */
  i1 = t4->size[0] * t4->size[1];
  t4->size[0] = 1;
  t4->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t4, i1);
  loop_ub = q->size[0] * q->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    t4->data[i1] = q->data[i1] + 0.0001;
  }

  emxInit_real_T(&t3, 2);
  i1 = t3->size[0] * t3->size[1];
  t3->size[0] = 1;
  t3->size[1] = q->size[1];
  emxEnsureCapacity_real_T(t3, i1);
  loop_ub = q->size[0] * q->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    t3->data[i1] = q->data[i1] * 10000.0 + 1.0;
  }

  i1 = G->size[0] * G->size[1];
  G->size[0] = 1;
  G->size[1] = q->size[1];
  emxEnsureCapacity_real_T(G, i1);
  loop_ub = q->size[0] * q->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    G->data[i1] = q->data[i1] / 2.0 + 5.0E-5;
  }

  emxInit_real_T(&r1, 2);
  b_sin(G);
  i1 = r1->size[0] * r1->size[1];
  r1->size[0] = 1;
  r1->size[1] = t4->size[1];
  emxEnsureCapacity_real_T(r1, i1);
  loop_ub = t4->size[0] * t4->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    r1->data[i1] = t4->data[i1];
  }

  emxInit_real_T(&r2, 2);
  b_cos(r1);
  i1 = r2->size[0] * r2->size[1];
  r2->size[0] = 1;
  r2->size[1] = r1->size[1];
  emxEnsureCapacity_real_T(r2, i1);
  loop_ub = r1->size[0] * r1->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    r2->data[i1] = r1->data[i1] * 144.207;
  }

  b_rdivide_helper(r2, t3, r1);
  power(t3, r2);
  rdivide_helper(r2, t3);
  b_sin(t4);
  i1 = G->size[0] * G->size[1];
  loop_ub = G->size[0] * G->size[1];
  G->size[0] = 1;
  emxEnsureCapacity_real_T(G, loop_ub);
  loop_ub = i1 - 1;
  emxFree_real_T(&r2);
  for (i1 = 0; i1 <= loop_ub; i1++) {
    G->data[i1] = (G->data[i1] * -0.00721035 + r1->data[i1]) - t3->data[i1] *
      t4->data[i1] * 1.44207E+6;
  }

  emxFree_real_T(&r1);
  emxFree_real_T(&t3);
  emxFree_real_T(&t4);
}

/* End of code generation (G_gen.c) */
